= Rails Conditions

Rails Conditions encapsulate the facets of a business logic condition using a simple macro. Conditions can be combined via logical operators to form complex expressions.

=== Simple condition

  class User < ActiveRecord::Base
    attr_writer :logged_in
    condition :logged_in do
      @logged_in
    end
  end

The code above virtually generates:

  class User < ActiveRecord::Base
    attr_writer :logged_in
    
    module LoggedInFailed; end
    
    # The predicate method returning true / false
    def logged_in?
      @logged_in
    end

    # The bang method returning true / RailsConditions::Failed with condition mixin
    def logged_in!
      unless logged_in?
        e = RailsCondition::Failed.new
        e.extend LoggedInFailed
        raise e
      else
        return true
      end
    end
  end

=== Elsewhere defined predicate method

If the predicate method is elsewhere defined e.g. by an ActiveRecord boolean database field,
a block can be omitted and the existing predicate method is used.

  class User < ActiveRecord::Base
    # asssume boolean database field :is_admin
    # Rails automaticly generates a is_admin? method for this boolean field
    condition :is_admin
  end

=== Condition through precondition

A condition can be contructed from another condition. See complex preconditions, to
recognize the real power of Rails Conditions.

  class Document < ActiveRecord::Base
    # asssume boolean database field :active
    condition :active
    condition :can_be_edited, :if => :active
  end

=== Preconditions without condition definition

A explicit definition of a condition is not needed to use it as a precondition. The boolean
field active implicitly defines a predicacte method that could be used as a precondition.

  class Document < ActiveRecord::Base
    # asssume boolean database field :active
    condition :can_be_edited, :if => :active
  end

=== Condition through complex preconditions

Conditions may consist of multiple precondition conjuncted by ANDs (&) and ORs (|). The
binding of the single apersand and single pipe are the same as the doubles known as
boolean operators. You can also use parnthesis to adjust the binding.

  class Document < ActiveRecord::Base
    # asssume boolean database fields :public, :add_to_index, :expired, :spam
    condition :can_be_indexed, :if => :public & :add_to_index
    condition :can_be_deleted, :if => :expired | :spam
  end

=== Using conditions from other models as preconditions

You can use a condition of another model as a precondition. All features,
like preconditions without condition definition, can be used across multiple models.

  class User < ActiveRecord::Base
    # asssume boolean database fields :is_admin
    condition :owns_document do |document|
      id == document.user_id
    end
  end

  class Document < ActiveRecord::Base
    # asssume boolean database field :active
    belongs_to :user
    condition :can_be_edited, :if => (:active & :user_owns_posting) | :user_is_admin
  end

=== How to use Rails Conditions in the controller

Rails Conditions can help you simplify the control flow in your controller. In the
following example the bang method generated from a condition is used to make a statement. If
the statement is not true, the raised exception is used to decide how to handle this error
case.

  class User < ActiveRecord::Base
    condition :owns_document do |document|
      id == document.user_id
    end
  end

  class Document < ActiveRecord::Base
    # asssume boolean database field :expired
    belongs_to :user
    condition :can_be_destroyed, :if => :expired & :user_owns_posting
  end

  class DocumentsController < ApplicationController
    before_filter :authenticate_user

    def destroy
      @document = Document.find(params[:id])
      @document.can_be_destroyed!(@user)
      @document.detroy
    rescue Document::ExpiredFailed
      flash[:error] = 'The lifetime of this document has not ended. You can not destroy it.'
    rescue User::OwnsDocumentFailed
      flash[:error] = 'Hey, you are cheating! This is not your document!'
    end  
  end

=== How to use Rails Conditions in the view

Taking the above example the user can only destroy the document if he is the owner or the
document is not expired. So you only want him to show the destroy link if he actually
can destroy the document. The predicate method generated by the condition can help you in 
the view.

  <% for document in @documents -%>
    <%= document.title %>
    <%= link_to_if document.can_be_detroyed(@user), 'Destroy', :action => 'detroy' %>
  <% end -%>


Copyright (c) 2007 Norman Timmler and Tammo Freese, released under the MIT license